commit 3b8e9f1a2c5d7e4f9b3a6c8d2e5f1a7c9b4e6d8f
Author: Sarah Chen <sarah.chen@communityshare.io>
Date:   Wed Sep 25 10:15:42 2025 -0700

    Implement conflict detection algorithm
    
    Adds core logic for detecting overlapping reservations using
    PostgreSQL interval overlap queries. Handles edge cases including:
    - Exact boundaries (exclusive end time)
    - Same start times
    - Contained intervals
    - Container intervals
    
    Algorithm uses (start_time, end_time) OVERLAPS operator for
    efficient range queries with B-tree index support.

---
 src/services/reservation-service.js | 87 +++++++++++++++++++++++++++
 src/services/conflict-detector.js   | 124 ++++++++++++++++++++++++++++++++++++
 2 files changed, 211 insertions(+)

diff --git a/src/services/reservation-service.js b/src/services/reservation-service.js
new file mode 100644
index 0000000..f7d8e1a
--- /dev/null
+++ b/src/services/reservation-service.js
@@ -0,0 +1,87 @@
+const { Pool } = require('pg');
+const ConflictDetector = require('./conflict-detector');
+
+class ReservationService {
+  constructor(dbPool) {
+    this.db = dbPool;
+    this.conflictDetector = new ConflictDetector(dbPool);
+  }
+
+  /**
+   * Create a new reservation
+   * @param {Object} reservationData - Reservation details
+   * @returns {Promise<Object>} Created reservation
+   * @throws {ConflictError} If time slot conflicts with existing reservation
+   */
+  async createReservation(reservationData) {
+    const {
+      resourceId,
+      userId,
+      startTime,
+      endTime,
+      purpose,
+      specialRequirements
+    } = reservationData;
+
+    // Validate time range
+    if (new Date(startTime) >= new Date(endTime)) {
+      throw new Error('Start time must be before end time');
+    }
+
+    // Check for conflicts
+    const hasConflict = await this.conflictDetector.checkConflict(
+      resourceId,
+      startTime,
+      endTime
+    );
+
+    if (hasConflict) {
+      const alternatives = await this.conflictDetector.findAlternatives(
+        resourceId,
+        startTime,
+        endTime
+      );
+      
+      throw new ConflictError('Time slot unavailable', {
+        alternatives,
+        conflicts: hasConflict.conflicts
+      });
+    }
+
+    // Create reservation
+    const query = `
+      INSERT INTO reservations (
+        resource_id, user_id, start_time, end_time, 
+        status, purpose, special_requirements
+      )
+      VALUES ($1, $2, $3, $4, $5, $6, $7)
+      RETURNING *
+    `;
+
+    const values = [
+      resourceId,
+      userId,
+      startTime,
+      endTime,
+      'CONFIRMED',
+      purpose,
+      specialRequirements || null
+    ];
+
+    const result = await this.db.query(query, values);
+    return result.rows[0];
+  }
+
+  /**
+   * Get reservation by ID
+   */
+  async getReservation(reservationId) {
+    const query = 'SELECT * FROM reservations WHERE id = $1';
+    const result = await this.db.query(query, [reservationId]);
+    return result.rows[0];
+  }
+
+  // Additional methods: update, cancel, etc.
+}
+
+module.exports = ReservationService;
diff --git a/src/services/conflict-detector.js b/src/services/conflict-detector.js
new file mode 100644
index 0000000..c3d4e5f
--- /dev/null
+++ b/src/services/conflict-detector.js
@@ -0,0 +1,124 @@
+/**
+ * Conflict Detection Service
+ * 
+ * Detects overlapping reservations using PostgreSQL interval overlap queries.
+ * Algorithm handles all edge cases:
+ * - Exact boundaries (exclusive end time)
+ * - Same start/end times
+ * - Contained intervals
+ * - Container intervals
+ */
+class ConflictDetector {
+  constructor(dbPool) {
+    this.db = dbPool;
+  }
+
+  /**
+   * Check if proposed time slot conflicts with existing reservations
+   * 
+   * Uses PostgreSQL OVERLAPS operator:
+   * (start_a, end_a) OVERLAPS (start_b, end_b)
+   * Returns true if: start_a < end_b AND start_b < end_a
+   * 
+   * @param {number} resourceId - Resource to check
+   * @param {string} startTime - ISO 8601 datetime
+   * @param {string} endTime - ISO 8601 datetime
+   * @param {string} excludeReservationId - UUID to exclude (for updates)
+   * @returns {Promise<boolean|Object>} False if no conflict, conflict details if found
+   */
+  async checkConflict(resourceId, startTime, endTime, excludeReservationId = null) {
+    const query = `
+      SELECT 
+        id,
+        start_time,
+        end_time,
+        CASE
+          WHEN start_time <= $2 AND end_time >= $3 THEN 'CONTAINS'
+          WHEN start_time >= $2 AND end_time <= $3 THEN 'CONTAINED'
+          WHEN start_time < $2 THEN 'OVERLAPS_START'
+          ELSE 'OVERLAPS_END'
+        END as overlap_type
+      FROM reservations
+      WHERE resource_id = $1
+        AND status IN ('CONFIRMED', 'ACTIVE')
+        AND ($4::uuid IS NULL OR id != $4)
+        AND (start_time, end_time) OVERLAPS ($2::timestamptz, $3::timestamptz)
+      ORDER BY start_time
+    `;
+
+    const result = await this.db.query(query, [
+      resourceId,
+      startTime,
+      endTime,
+      excludeReservationId
+    ]);
+
+    if (result.rows.length === 0) {
+      return false;
+    }
+
+    return {
+      hasConflict: true,
+      conflicts: result.rows
+    };
+  }
+
+  /**
+   * Find alternative available time slots near requested time
+   * 
+   * Strategy:
+   * 1. Find slots before requested time
+   * 2. Find slots after requested time
+   * 3. Return up to 5 alternatives closest to requested time
+   * 
+   * @param {number} resourceId
+   * @param {string} startTime
+   * @param {string} endTime
+   * @returns {Promise<Array>} Array of alternative time slots
+   */
+  async findAlternatives(resourceId, startTime, endTime) {
+    const duration = new Date(endTime) - new Date(startTime);
+    const durationMs = duration;
+
+    // Get all reservations for this resource on the same day
+    const query = `
+      SELECT start_time, end_time
+      FROM reservations
+      WHERE resource_id = $1
+        AND status IN ('CONFIRMED', 'ACTIVE')
+        AND start_time::date = $2::date
+      ORDER BY start_time
+    `;
+
+    const result = await this.db.query(query, [resourceId, startTime]);
+    const existingReservations = result.rows;
+
+    const alternatives = [];
+    
+    // Find gaps between reservations
+    for (let i = 0; i < existingReservations.length - 1; i++) {
+      const currentEnd = new Date(existingReservations[i].end_time);
+      const nextStart = new Date(existingReservations[i + 1].start_time);
+      const gap = nextStart - currentEnd;
+
+      // If gap is large enough for requested duration
+      if (gap >= durationMs) {
+        alternatives.push({
+          startTime: currentEnd.toISOString(),
+          endTime: new Date(currentEnd.getTime() + durationMs).toISOString()
+        });
+      }
+
+      // Limit to 5 alternatives
+      if (alternatives.length >= 5) break;
+    }
+
+    return alternatives;
+  }
+
+  // Additional methods for checking specific conflict types
+}
+
+class ConflictError extends Error {
+  constructor(message, details) {
+    super(message);
+    this.name = 'ConflictError';
+    this.details = details;
+  }
+}
+
+module.exports = ConflictDetector;
+module.exports.ConflictError = ConflictError;
