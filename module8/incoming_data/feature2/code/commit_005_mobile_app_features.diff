diff --git a/mobile/src/screens/QRScannerScreen.js b/mobile/src/screens/QRScannerScreen.js
new file mode 100644
index 0000000..ea29f8c
--- /dev/null
+++ b/mobile/src/screens/QRScannerScreen.js
@@ -0,0 +1,195 @@
+import React, { useState, useEffect } from 'react';
+import {
+  View,
+  Text,
+  StyleSheet,
+  TouchableOpacity,
+  Alert,
+  ActivityIndicator
+} from 'react-native';
+import { Camera } from 'expo-camera';
+import { BarCodeScanner } from 'expo-barcode-scanner';
+import * as Location from 'expo-location';
+import axios from 'axios';
+import { useAuth } from '../context/AuthContext';
+
+const API_URL = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api';
+
+export default function QRScannerScreen({ navigation }) {
+  const [hasPermission, setHasPermission] = useState(null);
+  const [scanned, setScanned] = useState(false);
+  const [processing, setProcessing] = useState(false);
+  const [action, setAction] = useState('checkout'); // 'checkout' or 'checkin'
+  const { token } = useAuth();
+
+  useEffect(() => {
+    (async () => {
+      const { status: cameraStatus } = await Camera.requestCameraPermissionsAsync();
+      const { status: locationStatus } = await Location.requestForegroundPermissionsAsync();
+      setHasPermission(cameraStatus === 'granted' && locationStatus === 'granted');
+    })();
+  }, []);
+
+  const extractToken = (data) => {
+    // Parse QR code URL to extract token
+    try {
+      const url = new URL(data);
+      const token = url.searchParams.get('token');
+      return token;
+    } catch (error) {
+      // If not a URL, assume the data itself is the token
+      return data;
+    }
+  };
+
+  const handleBarCodeScanned = async ({ type, data }) => {
+    if (scanned || processing) return;
+
+    setScanned(true);
+    setProcessing(true);
+
+    try {
+      // Extract token from QR code data
+      const qrToken = extractToken(data);
+
+      if (!qrToken || qrToken.length !== 32) {
+        Alert.alert('Error', 'Invalid QR code format');
+        setScanned(false);
+        setProcessing(false);
+        return;
+      }
+
+      // Get current location
+      let location = null;
+      try {
+        const locationData = await Location.getCurrentPositionAsync({});
+        location = {
+          latitude: locationData.coords.latitude,
+          longitude: locationData.coords.longitude
+        };
+      } catch (error) {
+        console.warn('Could not get location:', error);
+      }
+
+      // Send scan request to backend
+      const response = await axios.post(
+        `${API_URL}/qr-codes/scan`,
+        {
+          token: qrToken,
+          action,
+          location
+        },
+        {
+          headers: {
+            Authorization: `Bearer ${token}`
+          }
+        }
+      );
+
+      if (response.data.success) {
+        const equipment = response.data.data.equipment;
+        Alert.alert(
+          'Success',
+          `Equipment ${action === 'checkout' ? 'checked out' : 'checked in'} successfully!\n\n${equipment.name}`,
+          [
+            {
+              text: 'OK',
+              onPress: () => {
+                setScanned(false);
+                setProcessing(false);
+                navigation.navigate('Checkouts');
+              }
+            }
+          ]
+        );
+      }
+    } catch (error) {
+      console.error('Scan error:', error);
+      Alert.alert(
+        'Error',
+        error.response?.data?.error || 'Failed to process QR code',
+        [
+          {
+            text: 'Try Again',
+            onPress: () => {
+              setScanned(false);
+              setProcessing(false);
+            }
+          }
+        ]
+      );
+    }
+  };
+
+  if (hasPermission === null) {
+    return (
+      <View style={styles.container}>
+        <ActivityIndicator size="large" />
+        <Text>Requesting permissions...</Text>
+      </View>
+    );
+  }
+
+  if (hasPermission === false) {
+    return (
+      <View style={styles.container}>
+        <Text style={styles.text}>
+          Camera and location permissions are required to scan QR codes
+        </Text>
+      </View>
+    );
+  }
+
+  return (
+    <View style={styles.container}>
+      <Camera
+        style={styles.camera}
+        onBarCodeScanned={scanned ? undefined : handleBarCodeScanned}
+        barCodeScannerSettings={{
+          barCodeTypes: [BarCodeScanner.Constants.BarCodeType.qr],
+        }}
+      >
+        <View style={styles.overlay}>
+          <View style={styles.header}>
+            <Text style={styles.title}>Scan QR Code</Text>
+            <Text style={styles.subtitle}>
+              {action === 'checkout' ? 'Check out equipment' : 'Check in equipment'}
+            </Text>
+          </View>
+
+          <View style={styles.scanArea} />
+
+          <View style={styles.actionSelector}>
+            <TouchableOpacity
+              style={[styles.actionButton, action === 'checkout' && styles.actionButtonActive]}
+              onPress={() => setAction('checkout')}
+              disabled={processing}
+            >
+              <Text style={[styles.actionButtonText, action === 'checkout' && styles.actionButtonTextActive]}>
+                Check Out
+              </Text>
+            </TouchableOpacity>
+            <TouchableOpacity
+              style={[styles.actionButton, action === 'checkin' && styles.actionButtonActive]}
+              onPress={() => setAction('checkin')}
+              disabled={processing}
+            >
+              <Text style={[styles.actionButtonText, action === 'checkin' && styles.actionButtonTextActive]}>
+                Check In
+              </Text>
+            </TouchableOpacity>
+          </View>
+
+          {processing && (
+            <View style={styles.processingOverlay}>
+              <ActivityIndicator size="large" color="#fff" />
+              <Text style={styles.processingText}>Processing...</Text>
+            </View>
+          )}
+        </View>
+      </Camera>
+    </View>
+  );
+}
+
+const styles = StyleSheet.create({
+  container: {
+    flex: 1,
+    backgroundColor: '#000'
+  },
+  camera: {
+    flex: 1
+  },
+  overlay: {
+    flex: 1,
+    backgroundColor: 'rgba(0,0,0,0.5)'
+  },
+  header: {
+    padding: 20,
+    paddingTop: 60,
+    alignItems: 'center'
+  },
+  title: {
+    fontSize: 24,
+    fontWeight: 'bold',
+    color: '#fff',
+    marginBottom: 5
+  },
+  subtitle: {
+    fontSize: 16,
+    color: '#ccc'
+  },
+  scanArea: {
+    flex: 1,
+    margin: 40,
+    borderWidth: 2,
+    borderColor: '#fff',
+    borderRadius: 12,
+    backgroundColor: 'transparent'
+  },
+  actionSelector: {
+    flexDirection: 'row',
+    padding: 20,
+    gap: 10
+  },
+  actionButton: {
+    flex: 1,
+    padding: 15,
+    borderRadius: 8,
+    backgroundColor: 'rgba(255,255,255,0.2)',
+    alignItems: 'center'
+  },
+  actionButtonActive: {
+    backgroundColor: '#007AFF'
+  },
+  actionButtonText: {
+    color: '#fff',
+    fontSize: 16,
+    fontWeight: '600'
+  },
+  actionButtonTextActive: {
+    fontWeight: 'bold'
+  },
+  processingOverlay: {
+    position: 'absolute',
+    top: 0,
+    left: 0,
+    right: 0,
+    bottom: 0,
+    backgroundColor: 'rgba(0,0,0,0.8)',
+    justifyContent: 'center',
+    alignItems: 'center'
+  },
+  processingText: {
+    color: '#fff',
+    fontSize: 18,
+    marginTop: 10
+  },
+  text: {
+    color: '#fff',
+    fontSize: 16,
+    textAlign: 'center',
+    padding: 20
+  }
+});
diff --git a/mobile/src/screens/CheckoutsScreen.js b/mobile/src/screens/CheckoutsScreen.js
new file mode 100644
index 0000000..f56c8d5
--- /dev/null
+++ b/mobile/src/screens/CheckoutsScreen.js
@@ -0,0 +1,152 @@
+import React, { useState, useEffect } from 'react';
+import {
+  View,
+  Text,
+  FlatList,
+  StyleSheet,
+  RefreshControl,
+  TouchableOpacity,
+  ActivityIndicator
+} from 'react-native';
+import axios from 'axios';
+import { useAuth } from '../context/AuthContext';
+
+const API_URL = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api';
+
+export default function CheckoutsScreen() {
+  const [checkouts, setCheckouts] = useState([]);
+  const [loading, setLoading] = useState(true);
+  const [refreshing, setRefreshing] = useState(false);
+  const { token } = useAuth();
+
+  useEffect(() => {
+    fetchCheckouts();
+  }, []);
+
+  const fetchCheckouts = async () => {
+    try {
+      const response = await axios.get(`${API_URL}/checkouts/my-checkouts`, {
+        headers: {
+          Authorization: `Bearer ${token}`
+        }
+      });
+      setCheckouts(response.data.data);
+    } catch (error) {
+      console.error('Error fetching checkouts:', error);
+    } finally {
+      setLoading(false);
+      setRefreshing(false);
+    }
+  };
+
+  const onRefresh = () => {
+    setRefreshing(true);
+    fetchCheckouts();
+  };
+
+  const formatDate = (dateString) => {
+    const date = new Date(dateString);
+    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
+  };
+
+  const renderCheckout = ({ item }) => {
+    const isActive = item.status === 'active';
+    
+    return (
+      <View style={styles.checkoutCard}>
+        <View style={styles.cardHeader}>
+          <Text style={styles.equipmentName}>{item.equipmentId?.name || 'Unknown Equipment'}</Text>
+          <View style={[styles.statusBadge, isActive ? styles.statusActive : styles.statusCompleted]}>
+            <Text style={styles.statusText}>
+              {isActive ? 'CHECKED OUT' : 'COMPLETED'}
+            </Text>
+          </View>
+        </View>
+        
+        <View style={styles.cardBody}>
+          <View style={styles.infoRow}>
+            <Text style={styles.label}>Checked Out:</Text>
+            <Text style={styles.value}>{formatDate(item.checkoutDate)}</Text>
+          </View>
+          
+          {item.checkinDate && (
+            <View style={styles.infoRow}>
+              <Text style={styles.label}>Checked In:</Text>
+              <Text style={styles.value}>{formatDate(item.checkinDate)}</Text>
+            </View>
+          )}
+          
+          {item.checkoutMethod === 'qr_code' && (
+            <View style={styles.methodBadge}>
+              <Text style={styles.methodText}>QR Code</Text>
+            </View>
+          )}
+        </View>
+      </View>
+    );
+  };
+
+  if (loading) {
+    return (
+      <View style={styles.centerContainer}>
+        <ActivityIndicator size="large" color="#007AFF" />
+      </View>
+    );
+  }
+
+  return (
+    <View style={styles.container}>
+      <View style={styles.header}>
+        <Text style={styles.title}>My Checkouts</Text>
+      </View>
+      
+      <FlatList
+        data={checkouts}
+        renderItem={renderCheckout}
+        keyExtractor={(item) => item._id}
+        contentContainerStyle={styles.listContainer}
+        refreshControl={
+          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
+        }
+        ListEmptyComponent={
+          <View style={styles.emptyContainer}>
+            <Text style={styles.emptyText}>No checkouts yet</Text>
+          </View>
+        }
+      />
+    </View>
+  );
+}
+
+const styles = StyleSheet.create({
+  container: {
+    flex: 1,
+    backgroundColor: '#f5f5f5'
+  },
+  centerContainer: {
+    flex: 1,
+    justifyContent: 'center',
+    alignItems: 'center'
+  },
+  header: {
+    backgroundColor: '#fff',
+    padding: 20,
+    paddingTop: 60,
+    borderBottomWidth: 1,
+    borderBottomColor: '#e0e0e0'
+  },
+  title: {
+    fontSize: 28,
+    fontWeight: 'bold'
+  },
+  listContainer: {
+    padding: 15
+  },
+  checkoutCard: {
+    backgroundColor: '#fff',
+    borderRadius: 12,
+    padding: 15,
+    marginBottom: 15,
+    shadowColor: '#000',
+    shadowOffset: { width: 0, height: 2 },
+    shadowOpacity: 0.1,
+    shadowRadius: 4,
+    elevation: 3
+  },
+  cardHeader: {
+    flexDirection: 'row',
+    justifyContent: 'space-between',
+    alignItems: 'flex-start',
+    marginBottom: 12
+  },
+  equipmentName: {
+    fontSize: 18,
+    fontWeight: '600',
+    flex: 1,
+    marginRight: 10
+  },
+  statusBadge: {
+    paddingHorizontal: 10,
+    paddingVertical: 5,
+    borderRadius: 12
+  },
+  statusActive: {
+    backgroundColor: '#4CAF50'
+  },
+  statusCompleted: {
+    backgroundColor: '#9E9E9E'
+  },
+  statusText: {
+    color: '#fff',
+    fontSize: 10,
+    fontWeight: 'bold'
+  },
+  cardBody: {
+    gap: 8
+  },
+  infoRow: {
+    flexDirection: 'row',
+    justifyContent: 'space-between'
+  },
+  label: {
+    fontSize: 14,
+    color: '#666'
+  },
+  value: {
+    fontSize: 14,
+    color: '#333',
+    fontWeight: '500'
+  },
+  methodBadge: {
+    alignSelf: 'flex-start',
+    backgroundColor: '#E3F2FD',
+    paddingHorizontal: 8,
+    paddingVertical: 4,
+    borderRadius: 8,
+    marginTop: 4
+  },
+  methodText: {
+    fontSize: 12,
+    color: '#1976D2',
+    fontWeight: '500'
+  },
+  emptyContainer: {
+    flex: 1,
+    justifyContent: 'center',
+    alignItems: 'center',
+    paddingTop: 60
+  },
+  emptyText: {
+    fontSize: 16,
+    color: '#999'
+  }
+});
diff --git a/mobile/src/services/websocket.js b/mobile/src/services/websocket.js
new file mode 100644
index 0000000..8a4d3e5
--- /dev/null
+++ b/mobile/src/services/websocket.js
@@ -0,0 +1,85 @@
+import io from 'socket.io-client';
+
+const SOCKET_URL = process.env.EXPO_PUBLIC_SOCKET_URL || 'http://localhost:3000';
+
+class WebSocketService {
+  constructor() {
+    this.socket = null;
+    this.listeners = new Map();
+  }
+
+  connect(token) {
+    if (this.socket?.connected) {
+      console.log('WebSocket already connected');
+      return;
+    }
+
+    this.socket = io(SOCKET_URL, {
+      auth: { token },
+      transports: ['websocket'],
+      reconnection: true,
+      reconnectionDelay: 1000,
+      reconnectionAttempts: 5
+    });
+
+    this.socket.on('connect', () => {
+      console.log('WebSocket connected');
+    });
+
+    this.socket.on('disconnect', () => {
+      console.log('WebSocket disconnected');
+    });
+
+    this.socket.on('connected', (data) => {
+      console.log('Connection confirmed:', data);
+    });
+
+    this.socket.on('error', (error) => {
+      console.error('WebSocket error:', error);
+    });
+  }
+
+  disconnect() {
+    if (this.socket) {
+      this.socket.disconnect();
+      this.socket = null;
+      this.listeners.clear();
+    }
+  }
+
+  subscribeToEquipment(equipmentId) {
+    if (this.socket) {
+      this.socket.emit('subscribe:equipment', equipmentId);
+    }
+  }
+
+  unsubscribeFromEquipment(equipmentId) {
+    if (this.socket) {
+      this.socket.emit('unsubscribe:equipment', equipmentId);
+    }
+  }
+
+  on(event, callback) {
+    if (this.socket) {
+      this.socket.on(event, callback);
+      
+      // Store listener for cleanup
+      if (!this.listeners.has(event)) {
+        this.listeners.set(event, []);
+      }
+      this.listeners.get(event).push(callback);
+    }
+  }
+
+  off(event, callback) {
+    if (this.socket) {
+      this.socket.off(event, callback);
+      
+      // Remove from stored listeners
+      const eventListeners = this.listeners.get(event) || [];
+      this.listeners.set(event, eventListeners.filter(cb => cb !== callback));
+    }
+  }
+}
+
+export default new WebSocketService();
